\documentclass[sigconf]{acmart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
%\usepackage{authblk}
\usepackage{graphicx}
\usepackage{courier}
\usepackage{listings}

\lstset{%
  basicstyle=\small\ttfamily,
  language={Python}
}
%\AtBeginDocument{%
%  \providecommand\BibTeX{{%
%    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{rightsretained}
\copyrightyear{2021}
\acmYear{2021}
\acmDOI{}
\acmConference[CYBR-8950 Cybersecurity Capstone]{Cybersecurity Capstone}{Spring 2021}{Omaha, NE}
\acmBooktitle{CYBR-8950 Cybersecurity Capstone}
\acmISBN{}

% TODO: Better title if we're publishing
\title{Quantum Communications and Cryptography}

\author{Henry McNeil}
\email{hcmcneil@unomaha.edu}
\affiliation{%
  \institution{University of Nebraska, Omaha}
  \streetaddress{6001 Dodge St}
  \city{Omaha}
  \state{Nebraska}
  \postcode{68182}
}

\author{Zexi Xing}
\email{zxing@unomaha.edu}
\affiliation{%
  \institution{University of Nebraska, Omaha}
  \streetaddress{6001 Dodge St}
  \city{Omaha}
  \state{Nebraska}
  \postcode{68182}
}

\author{Casey Schmitz}
\email{caseyschmitz@unomaha.edu}
\affiliation{%
  \institution{University of Nebraska, Omaha}
  \streetaddress{6001 Dodge St}
  \city{Omaha}
  \state{Nebraska}
  \postcode{68182}
}

\author{Bryan Tomey}
\email{btomey@unomaha.edu}
\affiliation{%
  \institution{University of Nebraska, Omaha}
  \streetaddress{6001 Dodge St}
  \city{Omaha}
  \state{Nebraska}
  \postcode{68182}
}

\begin{abstract}
Quantum computers provide many new opportunities for cryptography, such as key distribution, confidentiality, integrity, and non-repudiation. Because of the destructive and probabilistic nature of quantum measurements and the no-cloning theorem which prevents the duplication of quantum states, quantum cryptographic protocols are dramatically different from classical cryptography. A large number of these protocols have been proposed, but little comparative work has been done. We perform a survey of existing protocols, with a focus on practical applications, in order to provide an overview of the current state of the field. We also present an implementation of a practical quantum cryptographic algorithm capable of providing confidentiality, integrity, and non-repudiation. In addition, we generalize our implementation process in order to provide a template for the translation of algorithms from a research paper into a quantum programming framework.
\end{abstract}

\begin{document}
\settopmatter{printfolios=true}
\maketitle

%1. Introduction
%    1. General Introduction
%    2. Background & Problem Context
%    3. Motivation
%        1. Gaps that currently exist, how the literature has evolved over time, what we're actually talking about in this paper
%        2. Related topics which are out of scope of this paper
%    4. Research Questions
%        1. **Research Question 1:** What are the impacts of quantum computing on today's commonly used cryptographic protocols for hashing, symmetric, and asymmetric encryption? Which of these protocols or classes of protocols need to be replaced by quantum or post-quantum solutions?
%        2. **RQ2:** What are the most promising techniques, either quantum or a hybrid of classical and quantum techniques, for maintaining the confidentiality of data at rest and in motion?
%        3. **RQ3:** What are ..., for verifying the integrity of data received?
%        4. **RQ4:** What are ..., for ensuring the authenticity and non-repudiation of messages?
%        5. **RQ5:** What standard process can be followed to translate a theoretical quantum algorithm into an implementation suitable for hands-on testing?
\section{Introduction}
Quantum computers have the world on the brink of a second computing revolution. By using the unique properties of subatomic particles, quantum computers will be able to solve complex problems in minutes which would take a classical computer thousands of years. Foremost among these problems are many which are foundational to modern cryptography, such as the prime factorization problem at the core of internet security. While current quantum computers do not have the level of sophistication necessary to break today's encryption systems, it is only a matter of time before they gain that capability. This project aims to explore the implications of quantum computing on cryptography in order to stay ahead of this anticipated threat and preserve the security of sensitive communications as used for everything from internet browsing to military instructions. 

In highly critical communications systems, such as those used to initiate a military action, messages must have guaranteed delivery, must not be tampered with, and must be authenticated and correct. These systems must not allow for false messages, which could lead to widespread loss of life in the worst case, so non-repudiation is a primary concern. 
The goal of this project is to identify the best ways for a critical system to send confidential messages with a guarantee of integrity and non-repudiation in a world where quantum computers are prevalent and capable. These cryptographic mechanisms may include quantum key distribution, quantum digital signatures, and quantum-resistant encryption algorithms performed on a classical computer.

\subsection{Background and Problem Context}
In the era of 5G high-speed internet surfing, data can be transmitted almost instantly from one side of the world to another. The downside of this technological convenience is that the secret information between both sides of a communication can be easy to expose to a malicious third party. Fortunately, current cryptographic algorithms are sufficient to protect users’ privacy because most of them are impossible to break with the computational power of traditional computers. However, when quantum computers become available, almost every currently used encryption algorithm will be vulnerable, and the massive data leakage will be inevitable. Hence, it is necessary to understand what quantum computers are and why they can destroy current existing cryptography.

A quantum computer is a type of physical device that is capable of bypassing many limitations of classical computers. Quantum computers take advantage of the principles of quantum mechanics to perform  high-speed mathematical and logical operations to store and process qubit information.\cite{shi_superconducting_2015}. Just as traditional computers distinguish between zeros and ones, or bits, by switching on and off logical gates in an integrated circuit, quantum computers have their own basic unit, the quantum bit. In these quantum bits, or qubits, the classical bit states 0 and 1 are replaced by two quantum states, $\rvert 0\rangle$ and $\rvert 1\rangle$. In a quantum computer, these states may be represented by the two orthogonal polarization directions of a photon, the spin directions of an electron in a magnetic field, the two directions of a nuclear spin, or the different energy levels of an electron in an atom.

A more significant difference between bits and qubits is that qubits can exist in a superposition of two logical states. “Unlike classical bits, a quantum bit can be put in a superposition state that encodes both 0 and 1. There is no good classical explanation of superpositions: a quantum bit representing 0 and 1 can neither be viewed as 'between' 0 and 1 nor can it be viewed as a hidden unknown state that represents either 0 or 1 with a certain probability.”\cite{rieffel_introduction_1998} Qubits can also become entangled with one another, which causes a measurement of one qubit to affect others. Hence, based on these attributes of qubits, quantum computers are able to process information differently and efficiently solve a different class of problems than classical computers.

\subsection{Motivation}
Encryption is omnipresent in modern life, with uses ranging from internet browsing to medical devices, wireless car keys to nuclear control systems. Quantum computing threatens almost all current encryption protocols in one way or another, whether by effectively weakening key strength, or breaking the algorithm entirely. As such, an understanding of the significance of quantum computing and new cryptographic protocols is critical, with impacts in areas ranging from personal privacy to national security.

Unlike in the last century, the struggle between countries is no longer a simple matter of using advanced weapons or geographical advantage to suppress or defeat the enemy. Instead, the main force of modern warfare is information transmission and manipulation, or information warfare.
In this case, it is extremely important to properly and securely transmit information between the agent and commander. For example, in highly critical communications systems, such as those used to initiate a military action, messages must have guaranteed delivery, must not be tampered with, and must be authenticated and correct. These systems must not allow for false messages, as these could lead to massive leakage of national confidentialities or even widespread loss of life in the worst case, so non-repudiation is a primary concern.
 
\subsection{Goals and Research Questions}
% Fix the tense here so we are clear on where we are in the overall process
In our research, we have focused on refining some contemporary quantum communication and cryptography methodologies from our research process. More specifically, we have tried to ensure that we have a comprehensive set of sources for use in our research, including representative samples of quantum cryptographic protocols that apply to confidentiality, integrity, and non-repudiation.

% Not actually our goal. TODO: Scattered focus
With the information gained from initial research in mind, we put effort on concluding some concrete results with respect to Quantum Key Distribution Protocols (QKDP) that can help our client understand both advantages and disadvantages of currently existing QKDP and those basic procedures need to be executed during the communication. Hence, we did a large research on quantum cryptographic algorithms, and we find most contemporary QKDPs are not possible to achieve because of the signal transmission channel losses, lack of ideal single photonic light source, and low detection efficiency of receiver etc. As a result, our goal is to seek out a QKDP that can be easy to implement with modern technological equipment and infrastructure, and it can also provide fairly sufficient security and transmission rate. 

% Phrasing? TODO: Scattered focus
As stated previously, our goal in this project is to identify the best ways for a critical system to send confidential messages with the guarantee of confidentiality, integrity, and non-repudiation in a world where quantum computers are prevalent and capable. These cryptographic mechanisms may include quantum key distribution, quantum digital signatures, and quantum-resistant encryption algorithms performed on a classical computer. As a result, we have proposed six questions below which we attempt to answer in this paper:
\begin{itemize}
\item Research Question 1: What are the impacts of quantum computing on today's commonly used cryptographic protocols for hashing, symmetric, and asymmetric encryption? Which of these protocols or classes of protocols need to be replaced by quantum or post-quantum solutions?
\item RQ2: What are the most effective quantum protocols for the creation and distribution of cryptographic secret keys?
\item RQ3: What are the most promising techniques, either quantum or a hybrid of classical and quantum techniques, for maintaining the confidentiality of data at rest and in motion?
\item RQ4: What are some reasonable transmission protocols that can be used for verifying the integrity of quantum data?
\item RQ5: What are the best quantum cryptographic algorithms for ensuring the authenticity and non-repudiation of messages?
\item RQ6: Can a standard process be followed to translate a theoretical quantum algorithm into an implementation suitable for hands-on testing?
\end{itemize}

%2. Related Work
%    1. (Basically recycling our literature review and chunking out into categories - port over, categorize, and refine)
%    1. Impacts of quantum computing on classical cryptography - Answers RQ1
%        1. Shor's algorithm impact on RSA and digital signatures
%        2. Grover's impact on AES and symmetric algorithms
%        3. Impact on hashing functions and authenticated encryption
%    2. Foundational papers in the different areas of quantum cryptography (like the original BB84 paper etc)
%    3. Attacks against quantum cryptography techniques
%        1. Photon splitting attacks
%        2. Denial of service
%        3. Man in the middle
%        4. Any others uncovered in final literature review
%    4. Include research methodology background for similar studies comparing different cryptographic algorithms
%        1. Found two different papers which fall into this category, can discuss here (Jorstad and Khan)
%    5. Post-quantum cryptography
%        1. NIST competition
%        2. Promising algorithms must not fall into BQP class (Bounded-error Quantum Polynomial)
\section{Related Work}
\subsection{Contemporary Quantum Communication and Cryptography} % TODO: Move all this over to methodology because these are the algorithms we selected for analysis
After reviewing some academic journals and authorized publications, we do find that current analysis of quantum technology is really covering a wide range and has significant achievement. But not all those resources are critical, some of those might run in the opposite direction against our goal and are hard to accomplish based on contemporary technology. As a result, our team categorized several feasible resources, whose theories might be possible to be utilized in the real world, into 5 groups with respect to the project goal.

\subsubsection{Quantum Encryption}
Quantum secure direct communication (QSDC) can perform symmetric encryption without the use of a public channel, which provides confidentiality, authentication, integrity, and non-repudiation. The scheme also allows for key reuse and does not require quantum error correction. The scheme does require the pre-sharing of an encryption key, though this could be accomplished with other QKD methods\cite{amerimehr_quantum_2018}.

\subsubsection{Quantum Key Distribution}

Shor’s algorithm poses a threat to current conventional cryptography and that QKD protocols have been proven to provide unconditional communication security. In some researcher analysis, they have compared results while some QKD protocols like BB84, B92, and BBM92 have been eavesdropped by a third party to check how many keys can be received and how many errors can occur during the transmission. Finally, they find if we can implement QKD in a proper way on a quantum computer, the unconditional quantum communications security can be proved\cite{nurhadi_quantum_2018}.

The current rate of key generating QKDN is a low speed. As a result, some other studies have explored another conception, which is called Quantum Key Pool (QKP), to mitigate the inefficiency of key production by storing generated keys. But the security of QKD will decrease because the QKP needs to store keys for a while, and the basic performance of QKDN will be harmed\cite{liu_multi-path_2019}.

There still exists a gap between the current QKD system and ideal one, some scientists have conquered this problem by using Decoy-State QKD scheme (DSQKD) to improve the security and performance of QKD transmission. However, in the DSQKD scheme, the pre-request is the data exchanges between two nodes are infinite. With the limited data exchanges rate of the real world QKD system, it is hard to achieve\cite{yu_study_2020}.

In ideal TF-QKD, the secure key rate scale can be enlarged to almost twice, so it can be used for a long-distance transmission which is much longer than the traditional QKD. In this case, TF-QKD not only maintains the confidentiality of data, but also can be used on a relevantly longer distance communication. Nevertheless, constructing the mode matching systems to finish the first interference of two types of lasers is very difficult\cite{park_research_2020}.


\subsubsection{Quantum Non-Repudiation}
Most quantum experts believe the digital signatures are an important aspect for verifying the integrity and authenticity of a message, so some researchers develop a scheme which uses a dynamic map based on quantum dots, a permutation and substitution scheme like AES, and DNA coding to create a quantum digital signature with a high degree of security as long as the signature is of sufficient length. In other words, by sending a dynamic quantum system's control parameter and critical points as well as some initial point in phase space, two parties could implement these digital signatures using a quantum computer, but without requiring a quantum channel for transmission\cite{hematpour_presence_2020}.

Quantum signatures can be used for both classical and quantum messages. The ability to sign a message using only a single qubit and a trusted third party is valuable. With Arbitrated Quantum Signatures (AQS), the key forgery is impossible, but perfect non-repudiation is not\cite{kang_quantum_2015}.

It may be possible that integrity, data origin authentication, and non-repudiation can be better achieved with quantum cryptographic methods. For example, some think Quantum Message Authentication Codes (QMACs) offer an advantage over classical methods for message authentication. However, after certain studies, researchers figured the information-theoretically secure message authentication are performed better in classical cryptography, and some known QMAC schemes are inferior to their classical counterparts\cite{nikolopoulos_information-theoretically_2020}.

Few researchers identify the binary classical messages can be authenticated by a set of QMAC protocols that, using a single qubit as the authentication key, allow for the successful authentication of messages with probability of forgery less than one. This QMAC protocol also provides the possibility of key reuse, though not with guaranteed security\cite{curty_quantum_2001}.


\subsubsection{Integrity and Post-Quantum Security} % Why is this combined?
By using an algorithm of amplitude amplification technique, quantum collision and multi-target preimage search, it can improve attacks against hash functions, key recovery in multi-user settings, and collision attacks on block cipher operation modes. This algorithm may also be used as building blocks for more complex cryptanalysis. In addition, the presented algorithm improves the on the time complexity of existing algorithms while requiring less quantum memory. Comparisons between new and existing algorithms are made under several conditions concerning the availability of quantum memory, ultimately suggesting that this new algorithm is superior unless quantum memory becomes as cheap as classical memory and parallelization is hard\cite{chailloux_efficient_2017}.

\subsection{Impacts of quantum computing on classical cryptography}
Quantum Computing offers an exponential growth to computational power. Quantum Computing’s computational power is directly proportional to the size of the system. This computational growth is called Computational parallelism and this growth is what makes Quantum Computing the potential next step in computing evolution. Quantum Computing by itself does not threaten encryption or communication, but when Quantum Computing is combined with Quantum Algorithms then there is potential for threat. To help mitigate the threat that Quantum Computing poses to Asymmetric Encryption Quantum Key Distribution was created to protect Asymmetrical Key Distribution. Quantum Computing could threaten current hashing standards and digital signatures, Quantum Non-Repudiation was developed to help protect digital signatures. As Quantum Computing grows it becomes a greater threat to standard encryption, then Quantum algorithms must be used to create mitigations to these threats.

\subsubsection{Shor's algorithm impact on RSA and digital signatures}
Peter Shor created a Quantum algorithm, called Shor’s Algorithm. Shor’s Algorithm is a Quantum Algorithm that uses polynomial time for factoring integers. Shor’s Algorithm is too resource intensive to be run by a common computer, to get the full effect of Shor’s Algorithm it needs to be run on a Quantum Computer. Shor’s Algorithm needs a high amount of Quantum bits, Quantum bits or qubits are a unit of Quantum information. Using Shor’s Algorithm which is a polynomial-time factorization problem that, with sufficient Qubits, can compromise the security of RSA, elliptic curve Diffie-Hellman and most other current asymmetrical encryption. For Shor’s Algorithm to threaten current asymmetrical encryption the number of qubits needed are higher than can be currently created. That does not mean that Asymmetric encryption is safe.\cite{shor_polynomial-time_1997}  
 
Asymmetric encryption is used to secure current communication systems and currently is a safe way to send data over the Internet. This can all change with Quantum Computing so to secure future communication Quantum Key Distribution (QKD) is being developed to help secure communication. Quantum Key Distribution is a One-Time-Pad encryption “As we all known, One-Time-Pad is the most secure way to build communication between two network nodes, so the Quantum Key Distribution (QKD) is taking advantage from it to build a much safer network environment called QKDN”\cite{liu_multi-path_2019}. 

\subsubsection{Grover's impact on AES and symmetric algorithms}
The quantum search algorithm proposed by Grover is a powerful algorithm of quantum computing, which is suitable for solving the following problem: to find a specific object from N unclassified objects. More specifically, the classical algorithm can only search one after another until it finds the object it wants. This algorithm has $O(N)$ complexity on average, whereas Grover's quantum algorithm only has $O(\sqrt{N})$ complexity on average\cite{canteaut_implementing_2020}.

For example, Grover’s algorithm can reduce the time required for brute force attacks. For public key encryption algorithms such as AES and 3DES, a quantum computer can reduce the security of keys by a factor $O(\sqrt{n})$, rendering the problem of brute forcing a 256-bit key equivalent to brute forcing a 128-bit key with a traditional computer. The algorithm proposed by Grover reduces the time of collision attack and reduces the security strength of hash function. With the quantum computer, the security strength of SHA256 was also reduced from 128-bits to 80-bits or less, and the security strength of SHA384 was reduced from 192-bits to 128-bits\cite{takagi_applying_2016}.

In 2019, Google used a 53-qubit quantum computer to prove that quantum computing systems have some special capabilities that can beat traditional computers (solving a problem that would take supercomputers 1,000 years to solve at 2.30 minutes), despite IBM's dissenting opinion that it would take only two days instead of 1,000 years. But it has essentially shown that quantum computers do outperform traditional supercomputers on specific problems that will take humanity to new horizons never explored before.\cite{arute_quantum_2019}

\subsubsection{Impact on hashing functions and authenticated encryption}
With the spread of the conception of decentralized systems, blockchain technology has gradually become another trend as a brand-new model of transactions. In terms of Bitcoin mining, it is well known that mining requires high-power equipment. Crypto asset miners use the computing power of computers to solve mathematical problems. Some of these people are running traditional computers, while others have purchased ASIC equipment for crypto mining. For the miners, a block reward is awarded to whoever solves a math problem first, meaning that the more powerful the computer, the greater the chance it will solve the problem and receive a reward paid in Bitcoin (BTC). So, what exactly is the math problem? This is called a block hash, and it takes miners some time to calculate the hash of each block. The total amount of computing power used by miners on the Bitcoin network is called the hash rate. Because competition in mining work is intensive and there is not a lot of difference between the devices that miners use, it is impossible for any individual to control the network or overwhelm others hash generating speed.

Based on the above illustration, we know having a better configured superior computer could bring huge benefits that allow one person or group to gain an advantage over, or even control, the network. Thus, the cryptocurrencies mining industry might be threatened by quantum computation power.

Exactly, the computing power of a quantum computer is completely different from a traditional computer, so it will break the current balance in the Bitcoin network. For example, a quantum computer could easily gain 51\% of total Bitcoin's hash rate and launch what is known as a 51\% attack (also called Double Spending Attack). Such an attack would disrupt the normal operation of the network, would subvert transaction confirmation, and would even reverse confirmed transactions. In other words, the owners of quantum computers are able to completely control the Bitcoin world. Once this happens, it will be a chaos of the cryptocurrency market. 

\subsection{Attacks against quantum cryptography techniques}
\subsubsection{Photon Splitting Attack}
In the ideal BB84 protocol, an important assumption is that Alice uses a single photon source. However, it is difficult to prepare a single photon source in the actual system, and a weakly coherent light source is usually used, which can be obtained by attenuating the laser light source. The photon number distribution of weakly coherent light source obeys the Poisson distribution, and there is a non-negligible multi-photon component in it. For multiphoton components, Eve can eavesdrop using photon-number splitting (PNS) attacks.

The basic principle of PNS attack is as follows: Eve intercepts the weak coherent pulse sent by Alice to Bob and obtains the photon number information through quantum non-destructive measurement. For the part of the single-photon state, all interceptions are no longer sent to Bob; for the multi-photon part, Eve extracts one photon from it and stores it in its own quantum memory and sends the remaining photons to Bob through a low loss or even no loss channel (ideally). After Bob publishes his measurement basis vector, Eve measures the photons stored in his quantum memory under the same basis vector. Then, combining with the basis vector information published by Alice, Eve carries out the same data post-processing process as Bob, so that Eve can obtain the exact same key as Bob\cite{brassard_limitations_2000}.

\subsubsection{Denial of Service}
According to the NSA's report in 2020, they declared “Quantum key distribution increases the risk of denial of service. The sensitivity to an eavesdropper as the theoretical basis for QKD security claims also shows that denial of service is a significant risk for QKD”\cite{national_security_agency_nsa_quantum_nodate}.

Exactly, as the classical communication network, the quantum network is still vulnerable to Denial-of-Service attack. Briefly speaking, a DoS attack, or denial of service attack, refers to hackers trying to compromise the target machine or server to make it stop functioning, which is one of the common attack methods of hackers. To accomplish DoS attack, hackers generally send numerous malicious requests through the network to overuse the target resources until it has crashed, so other lawful users cannot correctly access these resources at the moment. In common, DoS can usually result in a huge financial loss regarding different areas like governments and enterprises\cite{noauthor_what_nodate}.

\subsubsection{Man in the Middle Attack}
QKD generates the necessary keys for the encryption algorithm to ensure the privacy of the communication, but QKD itself cannot provide an authentication mechanism to the source of the transmission. The security of QKD is weakened because it cannot prevent a Man-In-the-Middle attack from its own technical perspective. The NSA report raises serious questions about this, which cannot be avoided and cannot be left undiscussed\cite{national_security_agency_nsa_quantum_nodate}.

We could seek out this scenario from the quantum transmission layer. The sender randomly selects one of + and × for each qubit sent, and the receiver randomly selects one of + and × for each qubit received. The receiver then tells the sender its sending bases over an insecure channel, such as the Internet, and the sender indicates which parts of it are correct. In this case, the sender and receiver will ignore those qubits whose listeners are set incorrectly. The sender and receiver then compare half of the remaining qubits, and if there is an error indicating that there is an additional listener in addition to the receiver, whose presence interferes with the photon's vibrational direction. If there is no error, the bits are discarded and the remaining bits are used as the key. If an eavesdropper is present, he will cause the last check operation to fail, because he will change the state of the original photon and cause the qubits to turn out to be the wrong answer half the time.

Now, we could consider the man-in-the-middle attacks scenario. The initiator of a man-in-the-middle attack is a more powerful actor than the listener, who not only has access to the entire Internet communication packets between the two parties but can also modify those packets as whatever he wants. Thus, he can present himself as the receiver to the sender and present himself as the sender with respect to the receiver side.

Once the attack is started, the middleman randomly selects one of the + and × bases at the beginning of the communication, tampers with the message so that the sender receives the receiver’s bases that is exactly same with middleman’s bases, and tampers the message so that the receiver receives the correct pattern that is the qubits for which the middleman and the receiver have the same bases. In the final verification process, it is obvious that the sender and the middleman retain the same bits, and the middleman also knows the bits that the receiver retains\cite{fei_quantum_2018}.

% TODO: Polish this up because these two papers are really important to our work
\subsection{Research methodology of quantum cryptography algorithm}
As a result, since those attacks can compromise families of quantum cryptography, some security issues have been put on the table.  To avoid too many vulnerabilities being exposed to those malicious users, it is significant to make a basic metric of quantum cryptography and also evaluate the security level of QKD protocols. Fortunately, there are two groups of researchers who have performed related studies. For example, Jorstad and Smith\cite{jorstad_cryptographic_1997} would like to figure out a question like "Can a standard objective framework for the measurement and specification of cryptographic algorithm strength be created?" To answer it, their methodology relied heavily on known characteristics of existing algorithms and the ways in which they might be compared, 
% TODO: Long sentence here
and they focused on civilian encryption algorithms meant for use in commercial products and operating in Electronic Code Book (ECB) mode which covers symmetric and asymmetric algorithms. However, their work is somewhat dated due to the selection of algorithms, only including those that existed in 1997, but their proposed classification scheme is useful.

% TODO What does security depth mean?
With respect to the security level of QKD protocols, most contemporary QKD protocols have not been compared in the security depth; however, especially with regards to simulation and implementation, it is necessary to verify the deviation between the theoretical aspects and real-world usage. In this situation, Khan and his team members provide a simple quantitative comparison of 11 different QKD schemes across six different factors, as well as a simulated analysis of the BB84 and 2-dimensional KBM09 protocols\cite{khan_security_2020}. Based on their result, even though their experimental comparison is limited to only evaluating the Quantum Bit Error Rate (QBER) reliability of two protocols, it still shows useful guidance on the ways protocols can be compared both theoretically and experimentally and serves as a basic approach for the classification of the quantum cryptography schemes.

\subsection{Post-quantum cryptography}
The National Institute of Standards and Technology (NIST) is leading a project called Post Quantum Standardization (PQS), which aims to define new algorithms that can address quantum computer threats. The PQS project is now in its final stage and is expected to be completed within two years\cite{moody_nist_2020}.

In order to realize the transition to quantum secure computing, SSH, VPN, IPSec, SSL/TLS and other security protocols also need to be upgraded. These protocols need to be combined with existing protocols, but also need to introduce an additional layer to establish secure communication to protect against quantum attacks. This change will have an impact on asymmetric encryption and key generation algorithms, and it is necessary to increase the key size of symmetric cryptography algorithms. There is also an impact on performance and bandwidth. Hardware vendors will also need to upgrade their hardware to align and transition with these new algorithms.

Additionally, we need to promise those new algorithms must not fall into BQP class. The BQP class can be traced back to 1993, when computer scientists Ethan Bernstein and Umesh Vazirani defined a new class of complexity they called BQP for "bounded error quantum polynomial time"\cite{bernstein_quantum_1997}. They define this category as all the decision problems that a quantum computer can effectively solve -- problems where the answer is yes or no. In other words, for a BQP problem, there is a quantum algorithm that takes polynomial time to run and has a high probability of getting the right answer. For any given situation, the chance of getting the wrong answer should be less than $1/3$. BQP can also be regarded as the quantum computer version of BPP, which stands for Bounded-error, Probabilistic, and Polynomial time\cite{younes_bounded-error_2015}. 


%3. Methodology
%    1. Overview of methodology as described in technical plan
%        1. How algorithms were selected
%        2. How algorithms were classified
%            1. Different classification scheme was used for each intended function
%            2. Algorithms may appear in multiple categories if they provide multiple attributes e.g. both confidentiality and integrity
%            3. Explanation of criteria and why each was selected - TODO for team: Fill these in
%                1. QKD criteria - https://github.com/Vidmaster/cybr8950-quantum/blob/main/QKD%20Protocols.md
%                2. Confidentiality criteria
%                    1. Application
%                    2. Target data
%                    3. Key agility
%                    4. Resource requirements/limitations
%                4. Integrity criteria
%                    1. Verifiable
%                    2. Reliable
%                    3. One transmission or multiple
%                    4. Security principle (Hashing, Encryption, Digital Signature, etc.)
%                    5. Target (classical or quantum data)
%                5. Non-Repudiation criteria
%                    1. Blind or arbitrated
%                    2. Reusable
%                    3. One transmission or multiple
%                    4. Security principle (rotation, hashing, etc.)
%                    5. Target (classical or quantum data)
%                    6. Signature length vs. message length
%        3. How algorithms were evaluated as implementation candidates
%            1. Level of overall complexity
%            2. Practical applicability to research questions
%    2. Selection of algorithms
%        1. QKD - https://github.com/Vidmaster/cybr8950-quantum/blob/main/QKD%20Protocols.md
%        2. Confidentiality
%        3. Integrity
%        4. Non-Repudiation
%            1. Curty 2001
%            2. Kang 2015
%            3. Nikolopoulos 2020
%            4. Hematpour 2020
%    3. Classification
%        1. Envisioning this section as basically just being several tables accompanied by discussion
%    4. Evaluation
%        1. Implementation
%        2. Applicability to hypothetical use case
%        3. Ways to evaluate against possible attacks (if we get that far)
%    5. Revisit research questions and relevance to the methodology. If RQs overlap, can keep this structure, otherwise consider having a top level for each RQ and then go from there. Which part of our methodology addresses each question?
\section{Methodology}
In this paper we have discussed the Research Questions about quantum computing and classical computing security and how they can directly affect one another. In the course of setting up for our experiments, we found that using IBM’s gate-based quantum computers with Qiskit was the best way to create an environment that could be recreated and answer the Research Questions. Qiskit uses Python language and libraries to interact with quantum computers.

\subsection{Algorithms Selected}
% TODO: Can we move some of this work into the background/related work section?
In deciding what algorithms to use we first had to ask what algorithms would be used to break classical computing’s security. There were some questions that helped us narrow down our requirements, such as why is quantum computing considered the future of computing?  Current computers figure out how to do something by trying every possible combination and picking the correct one. Quantum Computers can try every combination at once, because of superposition a quantum computer can be the right path and all the wrong paths at the same time. Quantum computing uses uncertainty in its State, it both is and isn’t the right path. Using entanglement you can measure the answer without collapsing the Quantum state. Entanglement is two particles that are linked but physically separate. Using one set of the particles you can measure the state without collapsing the wave function.

To secure classical computing against the future potential of quantum computing, Shor’s Algorithm researchers have created lattice and ring based encryption. Lattice and ring based encryption are based on mathematical algorithms that have been studied since the 1980 and no known attack has worked on them. Quantum computing can use quantum key distribution to secure its data in motion. quantum key distribution using BB84, Bennett and Brassard proposed this in 1984. BB84 can use multiplexing and is good out to 200 kilometers, without multiplexing it can go 240 km. Tools are not fully developed yet. Protocol E91 can use multiplexing and can transmit out to 200 km, 240 km without multiplexing. Protocol E91 Developed in 1991 by Arthur Ekert, using Protocol E91 the attackers can’t guess results. Protocol E91 is too resource intensive. MDI-QKD has the best range of 404 km, but it needs specialized configuration on the transmission channel. 

Grover’s algorithm has shown some promise against Symmetric algorithms but has not shown the ability to compromise AES at 256-bit key or above. Quantum computing’s nature makes its data at rest hard to tamper with and to completely insure that the data isn’t tampered with Zero Knowledge can be used. Zero Knowledge is based on the PCP theorem and uses a S=(P,V) proof and argument system. The PCP theorem is a decision problem checker based on the NP complexity class that uses probabilistically checkable proofs. Probabilistically checkable proofs are proofs used to check randomized algorithms. 

Each algorithm was chosen based on long standing research and proven methodologies.

\subsection{Algorithms Classified}
Each algorithm was chosen by how well it complements the Confidentiality, Integrity, and Availability (CIA) triad and if it was feasible to employ, with current quantum limitations versus future quantum computing threats. 

% TODO: Move up to related work
The other issues were what type of quantum computer do we choose, do we use Circuit model or Adiabatic. 

Adiabatic Quantum Algorithms are used to optimize the Hamiltonians, a function that represents all energy in a system. The Hamiltonian uses an operator to correspond to the energy of a system. The Hamiltonian corresponded to the total energy in both kinetic and potential energy. Quantum Adiabatic Algorithm (QAA) was designed to solve the optimization issues in Quantum Computing. QAA in a dedicated device will optimize the combinatorial optimization problem. The combinatorial optimization problem is solved by evolving adiabatically, only energy is transferred, when in the ground state. Adiabatic Quantum Computing can be as powerful as a non-stoquastic Hamiltonians in the circuit model. This means that the eigenvalue gap is at its minimum complicated many-body Hamiltonian. Adiabatic Quantum Algorithms allow for quantum speedup and can overcome some of the issues in qubit Quantum Computing, such as needing less qubits to crack asymmetric encryption. The issue with Adiabatic Quantum Computing is that it is inherently unstable as the qubits get higher, this creates a greater limitation to its future use. Adiabatic Quantum Algorithms are great for solving satisfiability problems and combinatorial search. 

The circuit model of quantum computing is the most common form of Quantum Computing currently. Circuit model Quantum Computing uses Hilbert space, vector space that allows defining lengths and angles, and has a series of unitary quantum logic gates to generate its qubits. Multiple quantum logic gates are connected together to generate more qubits. %no
A big difference between classical logic gates and quantum logic gates are that quantum logic gates are able to go backward and forwards, where classical logic gates can only move forwards. This reversibility of quantum logic gates allows for the Toffoli gate and can use all Boolean functions.  

% TODO Put this part in the analysis section for why we selected Qiskit
We used IBM’s Circuit model quantum computer. Companies like IBM have put out free to use Quantum Labs. Quantum Computer systems are too costly to get for students, so using IBM’s open-source SDK Qiskit was the best option available to us to do Quantum Computing research. IBM’s open-source SDK Qiskit has a Python interface that allows for a more familiar user interface.
% End move to related work

\subsection{Classification and Evaluation Criteria - Confidentiality} %Casey
Criteria for the classification and evaluation of quantum cryptosystems have not been formally defined by research institutions like NIST’s Computer Security Resource Center (CSRC). We determined the following criteria, derived in part from existing criteria for classifying and evaluating classical cryptosystems, to be appropriate for our classification and evaluation of quantum cryptosystems with respect to their ability to ensure confidentiality: % TODO Reorganize and shorten
\begin{itemize}
\item Application % TODO: Seems like just Confidentiality. Can maybe remove this one
\item Target data
\item Key characteristics and reusability
\item Resource requirements/limitations
\end{itemize}

Because there are several distinct applications for quantum cryptosystems, it is a valuable criterion by which to classify candidate systems and consider their real-world viability. The data that a cryptosystem works to secure is an important consideration in evaluating its candidacy for real-world implementation. As with classical cryptosystems, the characteristics and reusability of keys used in quantum cryptosystems can serve as a primary differentiator of comparable systems and as an indicator of potential system weaknesses and vulnerabilities. Notable resource requirements or limitations for a cryptosystem’s implementation are also important in considering a system’s viability in real-world applications.

\subsection{Classification and Evaluation Criteria - Non-Repudiation}
Henry's TODO here

\subsection{Criteria QKD}
Zexi todo - Just uses criteria from Khan paper. Do we have any other QKD protocols that weren't covered?

\subsection{Criteria Integrity}
Bryan todo

\subsection{Criteria of Algorithms in the CIA Triad} % TODO Remove availability here
% TODO: Henry The confidentiality part overlaps with Casey's section and others may overlap as well. consolidate all
Confidentiality is the protection of data while being processed, stored, and transported. % TODO Rephrase slightly
In classical computing, confidentiality is achieved in processing by symmetrical encryption such as AES or 3DES.
When data is in motion confidentiality can be achieved by Quantum Key Distribution, QKD can keep data encrypted while in motion. % TODO This is not what QKD is. QKD plus quantum authenticated encryption or any other protocols? Citation needed too
When data is stored AES 256 bit or higher is a good encryption to protect data. Confidentiality shares some of the same security needs as integrity and they overlap in the protection of data in motion. Confidentiality also shares some of the same security types as availability, such as data at rest needs to be encrypted. Controversially quantum computing has an attribute called noise, the noise in the environment around the quantum computer can change and interfere with the data. To reduce the effects of noise the quantum computing process is repeated many times in parallel with different noise and then the consistent data can be removed from the noise. This process allows for data integrity, keeping the data from being altered or damaged. % TODO: Citation needed

% Separate into different subsections
Integrity in classical computing deals with making sure that the data is real, accurate and secure. Making sure that the data is real and accurate can be an issue with quantum computing due to the inherent nature of quantum. 

It is hard to ensure integrity when the answer is neither right nor wrong until measured and analyzed. "This process is known as quantum parallelism. However, measuring the output states will randomly yield only one of the values in the superposition, and at the same time destroy all of the other results of the computation."\cite{rieffel_introduction_1998} The nature of quantum also lends to data integrity because of the wave function, if the data is tampered with it will change the superposition and collapse the wave function. The data will be safe from outside interference until it is quantum entanglement is measured. "Einstein, Podolsky, and Rosen proposed that each particle has some internal state that completely determines what the result of any given measurement will be."\cite{rieffel_introduction_1998} Integrity of data already retrieved from the quantum computer can be ensured. Data at rest can be encrypted with AES 256 bit or higher and data in motion can be secured with QKD. 

Integrity in classical computing can be hardened against the threat that quantum poises. To secure classical computing data at rest AES 256 bit or higher can be used and to secure data and to secure data in motion lattice and ring based encryption can be used. NTRUEncrypt is a lattice-based public-key Asymmetric encryption that is still being developed and worked on. NTRUEncrypt was first introduced in 1996 and is one of the most researched lattice-based encryptions designed to protect against quantum computing. % TODO Clarify - NTRU vs NTRUEncrypt vs Prime, as just NTRUEncrypt got the axe but was consolidated with others to be improved
"We choose implementations offering 128-bit security (except RSA-1024 offering 80-bit security) for comparison. Our AvrNTRU outperforms the RSA implementation, achieving 82.8 times faster decryption, even though RSA-1024 cannot match the same security level."\cite{cheng_h._lightweight_2021}. Currently quantum computing cannot produce enough qubits to threaten current encryption. van Oorschot-Wiener’s classical computing parallel collision searching algorithms is more of a threat to integrity then quantum computing currently\cite{oorschot_todo}.

% TODO Henry will incorporate into non-repudiation section
Non-Repudiation in quantum computing is much the same as classical computing in that the goal is to provide proof that the data has not been altered and the sender is who they claim to be. % Chonky, fix it
The issue is that a quantum state is not signable with quantum systems. % This is false, actually we need to take a different approach as classical signature mechanisms don't work for these reasons
The quantum state cannot be modified without collapsing the wave function, in non-repudiation you want to be able to reverse the process, the nature of quantum doesn’t allow this.  This raises the question, can a quantum state be encrypted with a public key and sent to another quantum computer, the answer is yes and QKD does this. 
The issue is can you guarantee non-repudiation with QKD, yes and no. We can say that the public key and the encrypted message along with the nature of the quantum state says that it can’t be tampered with, but it can still be intercepted in transit. QKD is still susceptible to Man-In-The-Middle Attack (MITM). To fix this the authentication step has been implemented using an initial secret key and this is called quantum authenticated encryption. A shared key is needed to mitigate a MITM attack which means symmetric encryption is needed to ensure asymmetric encryption and this raises the issue of whether you will need a different shared key for every user that receives this transmission.

Quantum signcryption allows one to sign a quantum state by layering a classical signature in the quantum state as part of the quantum state generation. When this quantum state is sent it will have a reversible classical signature layer in it. This can help with integrity but not with non-repudiation. There is a possibility that a malicious receiver could intercept and unwrap the quantum state then get the classical signature and imbed it into their own quantum state message. 

% TODO: Henry Phrasing of this section
Now for the contradiction, there is a quantum digital signature method that uses the dynamics of quantum dots to digitally sign a quantum state. This method uses the mapping of quantum dots, quantum dots are semiconducting particles which are created in the tiny divots in the silicon of the gate electrode. Quantum computers create these quantum dots as they create a quantum state and each one is unique to the quantum gate. Using the quantum dots with DNA alphabet and chaotic S-box creates a digital signature with a symmetric encryption. This quantum signature method looks secure but is far more complicated to produce than using quantum authenticated encryption and not proven to be more secure. To ensure non-repudiation in classical computing digital signing with NTRUEncrypt has been proven to be resistant to quantum computing and is less computationally intensive than the quantum computing vulnerable RSA\cite{cheng_h._lightweight_2021}.

% 3. Classification
%        1. Envisioning this section as basically just being several tables accompanied by discussion
\subsection{Classification} % TODO: This section is basically post-quantum evaluation and should go somewhere else.
% Move NIST/CSRC definition to just appear in the first usage, acronyms only otherwise
The Computer Security Resource Center (CSRC) and the National Institute of Standards and Technology (NIST) have been financing research into hardening systems against the future threat of quantum computing. The picture shown in fig 1 has all classical encryption candidates that have made it to the second round of CSRC and NIST testing. In fig 2 you can see that some of these didn’t make it to round 3. Using their guidelines of is it too slow to complete encryption given a reasonable time, is the key size two big and is there a known attack that works against it. Quantum computing is still in the beginning research stage and most algorithms for protecting data are being developed as quantum computing grows. To give the algorithms chosen proper consideration we will compare the quantum computing algorithms to the standards set by the CSRC and NIST. In Chart 1 is a list of quantum computing security measures and classical computing’s security measures. Based off of Chart 1 we will justify our choices in which security algorithms were chosen.

<This chart and figures omitted as they likely won't make the final paper>

% TODO Update depending on whether or not figures are kept
As shown NTRUprime, NTRUprime is an upgraded version of NTRU with a different design and security model but built on the same principles, has made it as a finalist and will get further testing. Also shown in chart 1 AES 256 bit or higher is very computationally intensive but it finishes computation in a reasonable time. The key size for AES is manageable so it gets medium size. There are currently no known compromises to AES 256 bit or higher which allows for high non-repudiation. QKD has a good score but is susceptible to MITM attack, if implemented with quantum authenticated encryption then MITM is mitigated. Quantum Signcryption key size is too large and it is susceptible to MITM. Dynamics of quantum dots is very computationally intensive and the key size is too large also. Using NIST guidelines we would recommend AES 256 bit or higher for classical computers. NTRUprime is still in the final testing phase but it is the oldest lattice based encryption that is secure against quantum computers, we would recommend it. Earlier in the paper we talked about NTRU’s ability to digitally sign for classical computing, the top contender for the NIST is Dilithium and Falcon for hashing.

Recommendations encryptions for quantum computing. QKD when paired with quantum authenticated encryption is a very strong method for ensuring non-repudiation with data in motion. AES 256 bit or higher to secure data at rest. Zero knowledge is a good protocol for ensuring data at rest and as proof of non-repudiation. Not recommended is Quantum Signcryption and Dynamics of quantum dots. Quantum Signcryption is susceptible to MITM attack and Dynamics of quantum dots key size is too large, for these two reasons they are not recommended.

% TODO Consider combining this section with the criteria selection above
\subsubsection{Confidentiality} % Casey - Discussion of selected algorithms. Include table here
To date, few quantum algorithms have been designed that are focused on ensuring confidentiality during the transmission of quantum or classical data. However, despite the lack of work regarding such quantum cryptosystems, a few proposed systems stand out as candidates for proof-of-concept implementation or to serve as a base for further research. Kak’s Three-Stage Protocol \cite{kak_three-stage_2006} is one of few entirely quantum solutions for data encryption through a public channel that can also serve as a simple method for key exchange. A scheme proposed by Amerimehr and Dehkordi\cite{amerimehr_quantum_2018} which - in addition to providing integrity, authenticity, and non-repudiation - ensures confidentiality during the transmission of classical data without the use of a public channel. Another scheme, proposed by Pleşa \cite{plesa_hybrid_2017}, achieves confidentiality by way of a multi-channeled, hybrid system. This system uses a quantum teleportation circuit for key exchange and a classical channel for data transmission and demonstrates the feasibility of near-term implementation of quantum cryptosystems that integrate with existing classical infrastructure.

\subsubsecion{QKD, Non-Reupdiation, Integrity}
Discussion goes here
% TODO: Add discussion and tables for each of these sections.

% TODO Reiterate research questions here?

\section{Analysis \& Results} % TODO: Maybe break into two sections?
\subsection{Implementation of a Quantum Cryptosystem}
%    1. Sample implementation of a selected algorithm
%        1. Challenges encountered during implementation
%        2. Limitations of our implementation
%        3. How this implementation could be used in practice
As a primary goal of this research was to identify quantum cryptographic algorithms with practical applications, we felt it necessary to implement a theoretical algorithm described in a research paper using a quantum programming framework. % Can revisit later in editing if we want to mention stakeholders
Qiskit was selected as our implementation tool of choice due to team member familiarity, its overall ease of use, quality of documentation, and simplicity of running against IBM's cloud-connected quantum hardware. The algorithm we identified as the most promising candidate for implementation was proposed by Amerimehr and Dehkordi in their 2018 paper "Quantum Symmetric Cryptosystem Based on Algebraic Codes"\cite{amerimehr_quantum_2018}, as the proposed system is simple and provides confidentiality, integrity, and non-repudiation. For simplicity we shall follow the naming convention used by BB84, B92, and others, and refer to this cryptosystem as AD18. % Standardize how we talk about AD18 between here and earlier

The algorithm itself resembles BB84 in that the transmitting party, Alice, selects random bases for the transmission of her message. While the recipient, Bob, measures the received qubits in a random basis in BB84, in AD18 Bob measures all of the received message values at a $22.5^{\circ}$ angle and encounters an approximately 15\% error rate in his measurements. The actual message sent by Alice includes an algebraic error correcting code of sufficient quality to correct the errors Bob encounters, thus allowing for a successful transmission without the public announcement of bases. Interspersed with the message qubits is a keyed hash value, and a pre-shared key is used in conjunction with some functions $f(k)$ and $g(k)$ to determine the locations and bases used in the transmission of the hash qubits. % Maybe unnecessary if we went into this detail earlier

The AD18 cryptosystem can be thought of in terms of quantum and classical components. The quantum piece simply involves preparing, transmitting, and measuring qubits. The classical component of the algorithm involves encryption, keyed hashing, and error correction. For the quantum component of the algorithm, we were able to leverage the BB84 code example provided in the Qiskit documentation\cite{noauthor_quantum_nodate} to demonstrate the preparation and measurement of qubits in different bases by applying a combination of X and H gates during preparation, and H gates during measurement. % Break this up
In AD18, as Bob is measuring in a $22.5^{\circ}$ basis, we applied an $R_Z$ gate with $\theta = -\pi/8$.

The classical portions of the algorithm involving encryption and hashing did not appear to be as important to the overall concept as qubit measurement and error correction. For ease of implementation, we selected a Salsa20 stream cipher with a 128-bit key for the encryption and decryption of the message, and an HMAC-MD5 keyed hash due to its short length. These protocols could easily be replaced with alternatives without materially impacting the functionality of the algorithm, though changes would affect the total number of bits sent and the overall security of the protocol. For our $f(k)$ function, we used a trivial implementation in which the message and hash are simply concatenated together, though this would need to be modified for a usable implementation in order to maintain the security of the system. The $g(k)$ function used to determine the transmission bases of the keyed hash was also kept simple, with Alice transmitting hash bit $H_i$ in $B_Z$ if $k_{i \mod len(k)} = 0$ and in $B_X$ otherwise.

The primary difficulty in successfully implementing this algorithm arose in the identification of an algebraic error correcting code (ECC) that was capable of handling the observed error rates for non-trivial messages. In the paper describing AD18, the authors transmit a two bit message which is expanded to five bits by their $[5,2,3]$ linear error correcting code. As we wished to transmit the significantly longer message "hello world", we selected the Python library \texttt{commpy} and used its convolutional coding functions. A transmission success rate of $>90\%$ on a three character message was achieved by using a memory size of 3 and a G-Matrix initialized with the value \texttt{array([[1, 3, 5, 7, 9, 11, 1, 3, 5, 7, 9, 11]])}. Simpler convolutional code trellises % TODO: Define convolutional code trellis in here somewhere
resulted in dramatically worse performance of the cryptosystem, with transmission success rates $<25\%$ per byte for a value \texttt{array([[5,7]])} with the same three character message. % Per message or per byte or???
Additionally, the G-Matrix used in our implementation would likely not be practical in a real implementation as it adds 100 bits of error correction per byte transmitted, which may not be feasible for use given the bitrates of current quantum channels.

A larger concern that is not specific to our implementation is that the algorithm does not provide a high level of consistency for the transmission of longer messages. An analysis of the algorithm's performance over 1000 executions for string lengths ranging from 1 to 8 using the above parameters shows a success rate of approximately $0.96$ per character transmitted, so for an 8 character message we expect and observe a success rate of $0.96^8 = 0.72$. While it may be possible to tune the error correction algorithms further to increase performance, the probabilistic nature of the quantum measurements combined with a hash check against the whole message means that the failure to correctly decode even a single bit of data using ECC will result in a significantly different hash value and thus a failure to authenticate the message.

While the authors are not experts in the field of error correcting codes and may have used a suboptimal mechanism in our implementation, we still find the proposed system to be impractical for non-trivial examples. When Bob makes his measurements in this cryptosystem, every bit measured has a $15\%$ chance to be measured incorrectly. As a result, there is always a non-zero probability of a decoding error regardless of the ECC used, and the overall error rate rapidly approaches a prohibitive level. For a trivial example with a two bit message and three bits of error correction as presented in the paper, the chance of Bob correctly measuring 4 or more bits as required for error correction is $0.85^5 + 5*(0.15\cdot 0.85^4) = 84\%$. If we use the same error correction mechanism and expand to 8 message bits with 12 bits of ECC, then the chance of correctly measuring a sufficient number of bits to decode the message falls to $50\%$, and is cut in half for each subsequent 20-bit block of error corrected data we append.

% TODO What's the maximum number of bits that can be feasibly sent at a reasonable error rate vs introduced overhead?

\subsection{General Process For Quantum Cryptographic Algorithm Implementation}
% Most commonly used gates for cryptography
%    2. General formula for implementation of quantum algorithms - Answers RQ5
%        1. How to identify an algorithm and turn it into a prototype implementation using Qiskit or similar
%        2. Limitations of this approach - what it works for, what it doesn't work for
%        3. Here’s a workflow that someone could follow to take a mathematical implementation from a research paper and turn it into an implementation using Qiskit or another framework.
%        4. Here’s an example we did following these steps, here are the challenges we encountered, insight into how to translate other frameworks besides Qiskit
As the act of implementing a proposed quantum algorithm can prove invaluable in uncovering its weaknesses, we believe that sharing and generalizing the methodology used in our implementation can benefit other researchers seeking to answer similar questions regarding other quantum cryptographic protocols. Our implementation was done in Qiskit, but this approach is language agnostic within the circuit-based quantum computing paradigm and is expected to apply to Cirq, Q\#, AWS Braket, and other quantum programming languages. The approach presented here has the additional limitation of not representing the transmission of quantum data, though this is largely a limitation of the current state of quantum programming.

The quantum cryptographic algorithms we reviewed are generally made up of the following four stages and their corresponding activities:
\begin{enumerate} % TODO Consistent tenses
\item Preparation: Pre-shared secrets established, channel selection, and values initialized as qubits.
\item Sender Processing: Cryptographic operations performed on message qubits.
\item Transmission: Transmission over selected channel and announcement of public values.
\item Recipient Processing: Cryptographic operations performed on message qubits, validation, and eavesdropper detection.
\end{enumerate}
Steps may be repeated or reordered, and roles may change, as may be observed in multi-party signature schemes where data is passed back and forth between sender, recipient, and a trusted third party, with various operations being applied along the way.

\subsubsection{Preparation}
In this stage of a cryptographic protocol, the sender and receiver establish a message channel, establish which pre-shared secret values to use, and prepare any necessary data. Should any classical cryptography, such as encryption or hashing, be required in the protocol, we recommend applying it at this stage whenever possible. Data preparation involving classical data can be done by converting into binary, then applying an $X$ gate to qubits which are meant to represent 1s in the binary data. As classical data can be large, it can quickly push simulators to their limits when trying to perform even simple operations on a 32-bit or larger classical value. To avoid this pitfall, consider that it is typically not necessary to construct a complicated circuit in which all values are processed in parallel, unless all of the qubits interact in some manner. Instead, consider representing the interaction as an array of simpler circuits. For quantum data, in this stage the sender would apply appropriate operations in order to set the qubits into the appropriate state, such as executing Grover's algorithm up to the final measurement stage prior to hypothetically signing and transmitting the results of this algorithm. We also recommend looking for places where initial preparation can be simplified without materially impacting the functionality of the protocol under study.

When implemented, the input to this stage should be classical data in the form of a string, byte array, bit array, or similar, and the output should be a quantum circuit or array of quantum circuits.

\subsubsection{Sender Processing}
This stage is the least specific as it will vary the most widely from protocol to protocol. The most common operations we observed in this stage were simple rotations, which are typically applied either as the Hadamard ($H$) gate or $R_{x,y,z}$ gates of arbitrary value. As the names of gates in quantum frameworks are generally well documented and only differ mildly amongst the various languages, referring to API documentation at this stage will resolve many challenges. Protocols which require custom unitary gate operations are also supported by many frameworks, such as Qiskit's \texttt{UnitaryGate} class.

When implemented, this stage will take as its input the quantum circuit that was produced in the preparation stage, and the output should be a quantum circuit or array of quantum circuits with additional operations applied.

\subsubsection{Transmission}
The quantum computing frameworks we have used do not provide the capability to easily represent the transmission of quantum data from one party to another. If noise or an eavesdropper are to be present, they must be represented with additional gates and measurements at this stage. In a typical eavesdropper scenario, Eve makes measurements using any available public information, then would retransmit the data to Bob. In some cases Eve may apply her own set of gates before retransmitting the data.

This stage can be omitted in most cases and simply represented as the passing of the quantum circuit from the previous stage to the recipient processing stage. If an eavesdropper, noise, or other events which impact transmission are to occur in the simulation, then the stage should accept and return a quantum circuit.

\subsubsection{Recipient Processing}
This stage can be quite protocol dependent as well, though it will frequently involve the application of one or more gates prior to taking a final measurement of the received qubits. After measurement, additional public sharing or comparison of values may take place. This public sharing of values is limited by the same lack of capability described in the transmission stage, but is usually easily represented by passing parameters into a function. For signature or hashing schemes, this is where a final validation of the signature or hash will occur, either by computing a classical keyed hash or by performing additional quantum operations involving a third-party arbitrator.

The implementation of this stage should take a quantum circuit to represent the data received by the recipient, and return either a classical value as in the case of encryption and decryption, or a boolean value indicating the success of the signature or hash validation.

\subsubsection{Workflow}
Our proposed workflow follows an iterative model of development, similar to that seen in test-driven development and agile methodologies. After identifying the desired algorithm for implementation, and validating that any quantum operations are supported by the chosen framework, the first step in this approach is to categorize the steps of the protocol into the previously described stages. In our implementations, we found it helpful to create a primary method to represent the full protocol, then create empty methods named for each stage, such as \texttt{alice\_prepare\_message} or \texttt{bob\_decrypt\_message}. For more complicated protocols, there will likely be multiple methods created for some of the stages. Before adding code to each method, it may be useful to describe the specific actions of the protocol in comments, and to identify which require classical data manipulation and which require quantum operations.

The second step of our workflow is to identify and initialize any values external to the algorithm under study, such as pre-shared secret keys or configuration of the quantum simulator. These should typically be defined as shared values outside the scope of any methods, as this makes them easier to locate and change and lowers the complexity of method signatures. We also highly recommend either using a standard logging library, or adding a boolean value \texttt{debug = true} so that helpful messages throughout the code can be conditionally enabled or disabled.

The next step in the workflow is to begin implementing the simplest possible version of the protocol by only coding the inputs and outputs of each stage. Use a small input of all zeros or a single letter string, create a quantum circuit with no gates or an identity gate for the transmission, only apply a measurement operation at the recipient, and perform any validation by simply returning \texttt{true} or \texttt{false}. This allows for easy verification that data is able to flow from end to end through the algorithm without introducing extra complexity. Judicious use of debugging statements at this stage can make later troubleshooting significantly simpler.

The fourth step should be to implement any classical operations used by the protocol, such as classical encryption, using appropriate libraries where possible. Validate that these operations function as expected outside of the quantum protocol under study, and add any relevant debugging statements.

In the final step, we implement the quantum portion of the algorithm within the structure we have created. Apply appropriate gate operations to the empty circuits that were constructed in the third step of the workflow, then test and verify the circuit on a local simulator. Once the protocol is functioning as expected, perform any desired refactoring activities. Creating a test harness which performs a repeated execution of the protocol with a variety of inputs, and validates the outputs, is highly recommended for any subsequent analysis.

\subsection{Example Using Kak's Three-Stage Protocol}
Using the workflow described above, we present a simple implementation of Kak's Three-Stage Protocol\cite{kak_three-stage_2006} for encryption of a single bit message. First, we categorize the steps of the protocol as follows:
\begin{itemize}
\item Preparation: Alice selects a value $x$ to transmit. Alice and Bob each establish their own secret key.
\item Sender processing 1: Alice applies $U_A = R(\theta)$ to her qubit.
\item Transmission 1: Alice transmits to Bob
\item Recipient processing 1: Bob applies $U_B = R(\phi)$ to the received qubit.
\item Transmission 2: Bob transmits back to Alice
\item Sender processing 2: Alice applies $U^\dagger_A$ to the qubit.
\item Transmission 3: Alice transmits back to Bob
\item Recipient processing 2: Bob applies $U^\dagger_B$ and has now decrypted the message.
\end{itemize}
As we are not planning to simulate an eavesdropper or noise in this protocol, all three transmission steps will not require any code and can simply be represented by comments and values being passed between methods. The stub of our Kak's protocol implementation after the completion of the first step of our implementation methodology can be seen in Listing \ref{lst:kak_s1}.

\begin{lstlisting}[caption={Implementation of Kak's Three-Stage Protocol, Step 1},label={lst:kak_s1},language=Python]
def kak_3_stage(message):
    prepared = alice_prepare_message(message)
    tr_1 = alice_apply_rotation(prepared)
    tr_2 = bob_apply_rotation(tr_1)
    tr_3 = alice_remove_rotation(tr_2)
    decrypted = bob_remove_rotation(tr_3)
    return decrypted
\end{lstlisting}

In the second step of our methodology, we can see that Kak's protocol uses two secret keys, which we can initialize as desired. As the secret keys are used to generate the $\theta$ and $\phi$ values used by Alice and Bob, we choose to generate a random value for each between 0 and $2\pi$ in order to keep the implementation simple. As seen in Listing \ref{lst:kak_s2}, we also create a \texttt{debug} flag and define \texttt{backend = qasm\_simulator} for use later. 

\begin{lstlisting}[caption={Implementation, Step 2},label={lst:kak_s2},language=Python]
debug = True
backend = 'qasm_simulator'
alice_key = np.random.uniform(0, 2*pi)
bob_key = np.random.uniform(0, 2*pi)
if debug:
    print("Alice's key: %s" % alice_key)
    print("Bob's key: %s" % bob_key)
\end{lstlisting}

Next, we can implement the simplest version of our methods in which Alice and Bob simply apply an $I$ gate at each step, and Bob performs a measurement in the final step. While most of these methods are trivial, the final one in which Bob performs his measurement will contain the code necessary to execute the quantum circuit on a simulator. The method for Bob's final rotation removal and measurement appears in Listing \ref{lst:kak_s3}.

\begin{lstlisting}[caption={Implementation, Step 3 (Partial)},label={lst:kak_s3},language=Python]
def bob_remove_rotation(qc):
    qc.i(0)
    qc.measure(0,0)
    if debug: print(qc)
    # Execute in simulator
    qasm_sim = Aer.get_backend(backend)
    qobj = assemble(qc, shots=1, memory=True)
    result = qasm_sim.run(qobj).result()
    return int(result.get_memory()[0])
\end{lstlisting}

As the protocol contains no classical functions, we move to the final step where we properly prepare Alice's message and implement rotation operators to replace the identity gates we used in the previous step. As Qiskit provides an $R_Z$ gate capable of performing an arbitrary rotation, we can use Alice and Bob's secret key values directly in this gate to apply their rotations. In the code, this simply involves replacing \texttt{qc.i(0)} with \texttt{qc.rz(alice\_key, 0)}, as seen in Listing \ref{lst:kak_s5}. After completing the implementation, we can verify that the operation works correctly by checking \texttt{kak\_3\_stage(0) == 0} and \texttt{kak\_3\_stage(1) == 1}. From this starting point, it would be possible to refactor the protocol to take a longer input, use a more complicated key generation method, or include an eavesdropper.

\begin{lstlisting}[caption={Implementation, Step 5 (Partial)},label={lst:kak_s5},language=Python]
def alice_remove_rotation(qc):
    qc.rz(-alice_key, 0)
    if debug: print(qc)
    return qc
\end{lstlisting}

\subsection{Discussion}
\subsubsection{Confidentiality}
While quantum computing’s contributions to confidential communications are most immediately going to come by way of Quantum Key Distribution paired with classical cryptography, it is clear that it could play a role in communication itself as the capabilities of quantum computers and networks improve.

For the confidentiality of data in motion, Kak’s Three-Stage Protocol is a foundational demonstration of entirely quantum encrypted communications that is capable of perfect security when accompanied by a classical protocol to ensure identity of communicating parties and a mechanism for error-checking/-correction \cite{kak_three-stage_2006}. % TODO longg boi
Kak’s Three-Stage Protocol has been extended by further research that address its shortcomings, including implementations that enable multi-photon transmissions \cite{mandal_multi-photon_2013} and the correction of errors that occur over a quantum channel \cite{parakh_correcting_2016}. While these advances bring the realization of an entirely quantum cryptosystem closer to near-term implementation in real-world applications, such solutions are limited by the capacity of circuit-based quantum processors which, at the time of writing, operate with less than 100 qubits \cite{noauthor_ibms_2020, arute_quantum_2019}. % TODO slightly long

The scheme proposed by Amerimehr and Dehkordi ensures confidentiality by using a single pre-shared encryption key, which is an advantage over similar schemes that rely on multiple secret keys, as a single key reduces pre-processing overhead \cite{amerimehr_quantum_2018}. In addition to providing a performance benefit, this pre-shared key can be reused securely, which is a desirable characteristic of a quantum cryptosystem that enhances its real-world viability. While this system’s theoretical capabilities are promising for real-world implementation, its reliability quickly degrades as message length increases, as demonstrated in \ref{sec:something} 4.1. %TODO Henry dynamic section reference
This is, again, largely due to the limited capacity of quantum computers and suggests that the cryptosystem should not be considered for real-world applications until the capacity of quantum processors increases or a more efficient algebraic ECC is implemented.

Despite their additional computational overhead, hybrid quantum cryptosystems like the one proposed by Pleşa are somewhat less reliant on the advancement of quantum computers because they transmit encrypted messages over classical channels. Ultimately, hybrid systems have a greater likelihood of real-world implementation in the near future. While this system can achieve confidentiality by use of a quantum circuit that guarantees perfect randomization\cite{plesa_hybrid_2017}, it requires each party to share a pair of entangled qubits. The challenges introduced in maintaining and transporting entangled qubits are not unique to this scheme, but are notable hindrances that are likely to delay the real-world implementation of this system.

At this time, quantum cryptography is an inappropriate solution for ensuring the confidentiality of data at rest. % TODO Casey Expand on this slightly


%    3. Tie back to research questions - what's our answer, and how did we get there?
%        1. RQ2 - Confidentiality
%            1. Have found a limited number of quantum algorithms which provide confidentiality. Quantum data can be "encrypted" using a one-time pad approach by applying a pre-shared set of random rotations to qubits before transmission, and removing them after. Quantum encryption with a classical key is also possible through quantum teleportation, as entangled qubits can be shared and then an arbitrary state teleported by transmitting two classical bits.
%            2. Quantum encryption of data at rest is not a relevant concern. Due to the no-cloning theorem and the destructive nature of quantum measurements, as well as the current short-lived nature of quantum data, qubits can be treated as always being "in motion", and separate encryption schemes are not necessary.
%            3. Post-quantum cryptography will be useful in the future, as these algorithms can be applied today with classical computers to protect data.
%        2. RQ3 - Integrity
%            1. Zero-Knowledge quantum integrity may be most promising
%        3. RQ4 - Non-Repudiation
%            1. Challenging due to the impossibility of verification without a third party
%            2. Signatures are frequently not reusable
%            3. Can provide value in some cases, but most promising approach is to use post-quantum signature techniques


\section{Conclusion}
In this paper we have explored the impacts of quantum computing on classical cryptography, examined the current state of the art of quantum cryptography, implemented and analyzed Amerimehr and Dehkordi's 2018 symmetric quantum encryption algorithm\cite{amerimehr_quantum_2018}, and presented a generalized process for the implementation of quantum cryptographic algorithms. The impacts of quantum computing on today's cryptographic systems are well understood, and efforts are being made by NIST to select suitable replacements for vulnerable public-key encryption, key-establishment, and signature algorithms\cite{moody_nist_2020, csd_postquantum_2017}. We identified promising quantum algorithms for important aspects of cryptography, including as TODO for key distribution, TODO for integrity, AD18 for encryption, and TODO for non-repudiation. While some of these algorithms, such as AD18, appear to need additional research and refinement to be practical for many applications, they can serve as a basis from which to build for future research.

To aid in future evaluations of quantum cryptographic protocols, we examined implementations of BB84, AD18, and Kak's Three-Stage Protocol, and proposed a standard process by which other researchers can approach the challenge of implementing quantum cryptographic algorithms. As the field of quantum cryptography is still in its infancy, our hope is that these final two contributions will be of particular value. Finally, we will provide recommended actions organizations can take today and in the near future to prepare themselves for advances in quantum computing and cryptography.

\subsection{Recommendations for Today}
Our first recommendation for organizations today is to gain an awareness of quantum computing, what problems it can and cannot be used to solve, and how it threatens current cryptographic systems. Outside of cutting edge security or research concerns, we do not believe it is necessary to immediately hire quantum specialists, but having an awareness of the state of the art in quantum computing will likely provide a competitive advantage to businesses over the next few years. Software engineers and security experts would benefit from learning the basic concepts of quantum computing as well, just as they have been encouraged to do with concepts such as cloud computing and machine learning in the recent past.

As today's most commonly used encryption systems are either weakened or broken by quantum computing, we highly recommend that companies be prepared to implement post-quantum encryption once final candidate algorithms are approved by NIST. Though quantum computers will not be capable of breaking RSA2048 for many years, encrypted data could still be captured by an adversary today and stored until decryption becomes feasible in the future. For data at rest, we recommend using AES with a 256-bit key length, and discontinuing the usage of 3DES and AES with 128- or 192-bit key lengths, as the impact of Grover's algorithm lowers the effective key lengths below those recommended by NIST in Section 3.4 of Special Publication 800-175B\cite{barker_guideline_2020}. TODO: add hashing and signature recommendations here.

\subsection{Recommendations for the Future}
It is extraordinarily difficult for experts to make accurate predictions of future developments in any field. The authors of this work make no claims to be more than novices in the field of quantum computing, but we felt we would be remiss to not provide a couple of broad predictions and accompanying recommendations for the next ten to twenty years.

In the next two decades, we predict that quantum computing will become widespread. Quantum computers will become more capable and easier to access, and an increasing number of companies will hire quantum computing experts. Quantum algorithms will be commonly used for applications such as entropy generation, key distribution, and optimization problems. If dramatic hardware advancements are made, we may even see specialized quantum processing units with a small number of qubits appear in personal computers. To stay ahead of these predictions, we reiterate our previous recommendation that organizations begin building their quantum computing capabilities. We also recommend that organizations be wary of the inevitable wave of charlatan companies that will promise expensive quantum computing offerings which are capable of solving all the world's problems.

As quantum computers become ubiquitous and capable, we predict that large numbers of new algorithms will be discovered. These algorithms will have broad impacts, ranging from threatening the security of previously safe cryptographic protocols, to producing rapid advances in materials science, medicine, and artificial intelligence. The technological and sociopolitical impacts of these new discoveries may alter society as fundamentally as industrialization, automobiles, aviation, and the internet did. Our recommendation is that organizations be prepared to adapt to rapid paradigm shifts in the security and technology landscape.

\subsection{Future Research}
In future work, we would like to further research and explore the encryption of quantum data, as this part of the field appears to be underdeveloped when compared to other aspects of quantum cryptography. In particular, we would like to research whether encryption protocols could diverge to handle quantum data at rest and in motion, as we have seen symmetric and asymmetric encryption develop in the classical realm. We believe an opportunity exists to further generalize our process for implementing quantum cryptographic algorithms, so that it can apply to non-circuit paradigms of quantum computing. We would also like to further explore the space of algebraic error correcting codes in order to revisit AD18 and improve the efficiency and overall capability of the protocol. % TODO Expand on signatures if we have findings

\bibliography{citations}{}
\bibliographystyle{ACM-Reference-Format}

\end{document}  
